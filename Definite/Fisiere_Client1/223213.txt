Test123PS D:\Proiect Retele\Proiect-Retele-Nr1> & C:/Users/ITeckX/AppData/Local/Microsoft/WindowsApps/python3.10.exe "d:/Proiect Retele/Proiect-Retele-Nr1/Definite/server.py"
{"type": "file", "file_name": "cerinta.txt"}
{"data": "Clientul se autentifica prin cont, trimitand server-ului o lista cu fisierele pe care le publica,\r\nsi primeste lista tuturor fisierelor publicate de catre ceilalti clienti autentificati;\r\nCand un client se autentifica, ceilalti clienti autentificati primesc o notificare de adaugare a acesuia, impreuna cu lista de fisiere pe care o publica;\r\nCand un client isi incheie sesiunea cu server-ul, aceste ii confirma incheierea sesiunii si notifica ceilalti clienti autentificati sa stearga din lista clientul respect", "status": "ok"}
{"data": "iv;\r\nUn client poate solocita server-ului descarcarea unui fisier de la alti clienti;\r\nServer-ul solicita detinatorului fisierului respetiv citirea continutului acestuia;\r\nUlterior, server-ul livreaza continutul fisierului clientului care l-a solicitat;\r\nClientul salveaza fisierul in sistemul sau de fisiere;\r\nFiecare client va avea un director gazda expus, care va fi monitorizat;\r\nLa adaugarea unui nou fisier in acest director, clientul va notifica prin intermediul server-ului adaugarea fisierului;\r\nLa ster", "status": "ok"}
{"data": "gerea unui fisier din acest director, clientul va notifica in mod similar ceilalti clienti prin intermediul server-ului.\r\n\r\nClient:\r\n-trimite date de logare, fisierele pe care le publica\r\n-primeste lista fisierelor expuse de restul clientilor\r\n-primeste notificare atunci cand se conecteaza alt client, contine numele si lista de fisiere publicate\r\n-trimite notificare serverului ca inchide sesiunea\r\n-primeste notificare cand se deconecteaza alt client\r\n-solicita descarcarea unui fisier de alt client, dupa con", "status": "ok"}
{"data": "firmare primeste de la server fisierul, il stocheaza\r\n-primeste solicitarea de descarcare a unui fisier\r\n-are un director gazda expus, este monitorizat\r\n-cand se modifica directorul gazda, notifica serverului\r\n\r\nServer:\r\n-primeste datele de logare si fisierele publicate de catre client\r\n-trimite clientului logat fisierele expuse in acel moment de catre clientii conectati\r\n-trimite notificare celorlalti clienti atunci cand se conecteaza un client, continand lista de fisiere expuse si numele\r\n-cand serverul p", "status": "ok"}
{"data": "rimeste notificarea ca un client s-a deconectat, trimite notificare clientilor care sunt conectati\r\n-primeste notificarea ca un client doreste sa descarce un fisier, serverul notifica clientul detinator, primeste acordul iar serverul trimite fisierul celui care l-a cerut\r\n-primeste notificarea pentru adaugare si stergere a unui fisier din directorul gazda, ulterior notifica restul clientilor de schimbare", "status": "ok"}
{"status": "over"}
[{'username': 'calin', 'files': ['cerinta.txt']}]
{"type": "file", "file_name": "server.py"}
{"data": "import socket\r\nimport threading\r\nimport pickle\r\nimport os\r\nimport json\r\n# Setari generale\r\nPORT = 8080\r\nSERVER = \"localhost\"\r\nADDR = (SERVER, PORT)\r\nFORMAT = \"utf-8\"\r\nDISCONNECT_MESSAGE = \"!DISCONNECT\"\r\nBUFFER_SIZE = 4096\r\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\ndef create_server():\r\n    # Creaz\u0103 un socket de tip TCP/IP\r\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n\r\n    # Permite folosirea aceluia\u0219i port dup\u0103 \u00eenchiderea serverului\r\n    server_socket.setsockopt(s", "status": "ok"}
{"data": "ocket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n\r\n    # Leag\u0103 socket-ul la o adres\u0103 \u0219i un port\r\n    server_address = (SERVER, PORT)\r\n    server_socket.bind(server_address)\r\n\r\n    # Ascult\u0103 conexiuni de la clien\u021bi\r\n    server_socket.listen(1)\r\n\r\n    # Returneaz\u0103 obiectul socket pentru server\r\n    return server_socket\r\n\r\n\r\nclass Client:\r\n    def __init__(self, name, files, client_socket):\r\n        self.name = name\r\n        self.files = files\r\n        self.client_socket = client_socket\r\nclass Server:\r\n    def", "status": "ok"}
{"data": "__init__(self):\r\n        self.clients = []\r\n\r\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n        self.server_socket.bind(ADDR)\r\n\r\n    def start(self):\r\n        print(\"A\u0219tept conexiuni...\")\r\n        self.server_socket.listen(5)\r\n        print(f\"[SERVER] Listening on {SERVER}\")\r\n\r\n        while True:\r\n            client_socket, client_addr = self.server_socket.accept()\r\n            print(f\"[NEW CONNECTION] {client_addr} connected.\")\r\n\r\n            # Creare thread separat", "status": "ok"}
{"data": "pentru fiecare conexiune client-server\r\n            thread = threading.Thread(target=self.handle_client, args=(client_socket,))\r\n            thread.start()\r\n            print(f\"Thread started\")\r\n\r\n    def handle_client(self, client_socket):\r\n        # Autentificare client\r\n        authenticated = False\r\n        client_name = \"\"\r\n        while not authenticated:\r\n            try:\r\n                # Primirea datelor de autentificare de la client\r\n                data = client_socket.recv(BUFFER_SIZE)", "status": "ok"}
{"data": "print(data)\r\n                if data:\r\n                    auth_data = pickle.loads(data)\r\n                    client_name = auth_data[\"name\"]\r\n                    client_files = auth_data[\"files\"]\r\n\r\n                    # Verificare dac\u0103 numele de utilizator exist\u0103 deja\r\n                    for client in self.clients:\r\n                      
  if client.name == client_name:\r\n                            response = {\"status\": \"error\", \"message\": \"Username already taken.\"}", "status": "ok"}
{"data": "client_socket.sendall(pickle.dumps(response))\r\n                            break\r\n                    else:\r\n                        # Ad\u0103ugare client la list\u0103 \u0219i trimiterea listei de clien\u021bi conecta\u021bi\r\n                        new_client = Client(client_name, client_files, client_socket)\r\n                        self.clients.append(new_client)\r\n                        response = {\"status\": \"ok\", \"message\": \"Authentication successful.\"}\r\n                        client_socket.sendall(pickle.dumps(res", "status": "ok"}
{"data": "ponse))\r\n                        authenticated = True\r\n\r\n                        # Notificare pentru ceilal\u021bi clien\u021bi despre ad\u0103ugarea unui nou client\r\n                        for client in self.clients:\r\n                            if client.client_socket != client_socket:\r\n                                notification = {\"type\": \"add\", \"name\": client_name, \"files\": client_files}\r\n                                client.client_socket.sendall(pickle.dumps(notification))\r\n            except:", "status": "ok"}
{"data": "pass\r\n\r\n        # Loop pentru gestionarea cererilor de la client\r\n        while True:\r\n            try:\r\n                data = client_socket.recv(BUFFER_SIZE)\r\n         
       if data:\r\n                    request = pickle.loads(data)\r\n\r\n                    # Verificare tip cerere\r\n                    if request[\"type\"] == \"publish\":\r\n          
              # Publicare fi\u0219ier\r\n                        for client in self.clients:\r\n                            if client.client_socket == client_socket:", "status": "ok"}
{"data": "client.files.append(request[\"file\"])\r\n                                response = {\"status\": \"ok\", \"message\": \"File published.\"}\r\n                                client_socket.sendall(pickle.dumps(response))\r\n                                break\r\n\r\n                        # Notificare pentru ceilal\u021bi clien\u021bi despre ad\u0103ugarea unui fi\u0219ier\r\n                        for client in self.clients:\r\n                            if client.client_socket != client_socket:", "status": "ok"}
{"data": "notification = {\"type\": \"file_add\", \"name\": client_name, \"file\": request[\"file\"]}\r\n                                client.client_socket.sendall(pickle.dumps(notification))\r\n\r\n                    elif request[\"type\"] == \"download\":\r\n                        # Desc\u0103rcare fi\u0219ier\r\n                        file_path = os.path.join(BASE_DIR, client_name, request[\"file\"])\r\n                        if os.path.exists(file_path):\r\n                            with open(file_path, \"rb\") as f:", "status": "ok"}
{"data": "file_data = f.read()\r\n                            response = {\"status\": \"ok\", \"file_data\": file_data}\r\n                        else:\r\n                            response = {\"status\": \"error\", \"message\": \"File not found.\"}\r\n                        client_socket.sendall(pickle.dumps(response))\r\n\r\n                    elif request[\"type\"] == \"list\":\r\n                        # Trimitere list\u0103 de fi\u0219iere publicate de ceilal\u021bi clien\u021bi\r\n                        file_list = []", "status": "ok"}
{"data": "for client in self.clients:\r\n                            if client.client_socket != client_socket:\r\n                                file_list += client.files\r\n                 
       response = {\"status\": \"ok\", \"file_list\": file_list}\r\n                        client_socket.sendall(pickle.dumps(response))\r\n\r\n                    elif request[\"type\"] == \"disconnect\":\r\n                        # Deconectare client \u0219i notificare pentru ceilal\u021bi clien\u021bi\r\n                        self.clients = [clie", "status": "ok"}
{"data": "nt for client in self.clients if client.client_socket != client_socket]\r\n                        response = {\"status\": \"ok\", \"message\": \"Disconnected.\"}\r\n                
        client_socket.sendall(pickle.dumps(response))\r\n                        for client in self.clients:\r\n                            if client.client_socket != client_socket:\r\n                                notification = {\"type\": \"remove\", \"name\": client_name}\r\n                                client.client_socket.sendall(pickle.dumps(n", "status": "ok"}
{"data": "otification))\r\n                        break\r\n            except:\r\n                break\r\n\r\n        # \u00cenchidere conexiune\r\n        print(f\"[DISCONNECT] {client_name} disconnected.\")\r\n        client_socket.close()\r\n\r\ndef main():\r\n    # Creeaz\u0103 serverul\r\n    server = Server()\r\n    server.start()\r\n\r\nif __name__ == '__main__':\r\n    main()", "status": "ok"}
{"status": "over"}
[{'username': 'calin', 'files': ['cerinta.txt', 'server.py']}]
{"type": "file", "file_name": "test.txt"}
{"status": "over"}
[{'username': 'calin', 'files': ['cerinta.txt', 'server.py', 'test.txt']}]